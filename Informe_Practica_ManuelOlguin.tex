%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%		PLANTILLA LATEX PARA INFORMES
%%%%			LATEX REPORT TEMPLATE
%%%%
%%%%	Autor	: Carlos Gonzalez Cortes
%%%%	Correo	: carlgonz@ug.uchile.cl
%%%%	Version	: 1.0
%%%%
%%%%	Notas	: Este codigo se entrega tal cual es y sin
%%%%			  ningun tipo de garantia. Sientase libre de
%%%%			  modificar y compartir.(acentos omitidos en
%%%%			  los comentarios por compatibilidad)
%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




\documentclass[11pt,letterpaper]{article}
\usepackage[spanish]{babel}
%\usepackage[ansinew]{inputenc}
\usepackage[utf8]{inputenc}
% \usepackage[latin1]{inputenc}
\usepackage[letterpaper,includeheadfoot, top=0cm, bottom=1.5cm, right=2.0cm, left=2.0cm, headheight=77pt]{geometry}
\renewcommand{\familydefault}{\sfdefault}

\usepackage{graphicx}
\usepackage{color}
\usepackage{hyperref}
\usepackage{amssymb}
\usepackage{url}
%\usepackage{pdfpages}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{subfig}

\usepackage{listings} %Codigo
\lstset{language=Python, tabsize=4,breaklines=true}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.8, 0.8, 0.8}

\lstdefinestyle{mystyle}{
    %backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=8pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=4
}

\usepackage{xcolor}

\colorlet{punct}{red!60!black}
\definecolor{background}{HTML}{EEEEEE}
\definecolor{delim}{RGB}{20,105,176}
\colorlet{numb}{magenta!60!black}

\lstdefinelanguage{json}{
    literate=
     *{0}{{{\color{numb}0}}}{1}
      {1}{{{\color{numb}1}}}{1}
      {2}{{{\color{numb}2}}}{1}
      {3}{{{\color{numb}3}}}{1}
      {4}{{{\color{numb}4}}}{1}
      {5}{{{\color{numb}5}}}{1}
      {6}{{{\color{numb}6}}}{1}
      {7}{{{\color{numb}7}}}{1}
      {8}{{{\color{numb}8}}}{1}
      {9}{{{\color{numb}9}}}{1}
      {:}{{{\color{punct}{:}}}}{1}
      {,}{{{\color{punct}{,}}}}{1}
      {\{}{{{\color{delim}{\{}}}}{1}
      {\}}{{{\color{delim}{\}}}}}{1}
      {[}{{{\color{delim}{[}}}}{1}
      {]}{{{\color{delim}{]}}}}{1},
}

\lstset{style=mystyle}


% footnote in footer
\newcommand{\fancyfootnotetext}[2]{%
  \fancypagestyle{dingens}{%
    \fancyfoot[LO,RE]{\parbox{12cm}{\footnotemark[#1]\footnotesize #2}}%
  }%
  \thispagestyle{dingens}%
}

\begin{document}
%\begin{sf}
% --------------- ---------PORTADA --------------------------------------------
\newpage
\pagestyle{fancy}
\fancyhf{}
%-------------------- CABECERA ---------------------
\fancyhead[L]{ \includegraphics[scale=0.3]{img/fcfm_dcc.pdf} }
%\fancyhead[R]{ \includegraphics[scale=0.4]{img/fcfm.png} }
%------------------ TÍTULO -----------------------
\vspace*{6cm}
\begin{center}
\Huge  {Informe de Práctica}\\
\vspace{1cm}
\small {CC4901 -- Práctica Profesional I}\\
\end{center}
%----------------- NOMBRES ------------------------
\vfill
\begin{flushright}
\begin{tabular}{ll}
Empresa: & NIC Chile Research Labs\\
Alumno: & Manuel Olguín\\
Carrera: & Ingeniería Civil en Computación\\
RUT:& 18.274.982 -- 6\\
E-Mail: & molguin@dcc.uchile.cl\\
Tel: & +56 9 7463 6997\\
& \today\\
& Santiago, Chile.
\end{tabular}
\end{flushright}

% ·············· ENCABEZADO - PIE DE PAGINA ············
\newpage
\pagestyle{fancy}
\fancyhf{}

%Encabezado
%\fancyhead[L]{\rightmark}
%\fancyhead[L]{\small \rm \textit{Sección \rightmark}} %Izquierda
%\fancyhead[R]{\small \rm \textbf{\thepage}} %Derecha

\fancyfoot[L]{\small \rm \textit{Sección \rightmark}} %Izquierda
\fancyfoot[R]{\small \rm \textbf{\thepage}} %Derecha

%\fancyfoot[L]{\small \rm \textit{Pie de página - Izquierda}} %Izquierda
%\fancyfoot[R]{\small \rm \textit{Pie de página - Derecha}} %Derecha
%\fancyfoot[C]{\thepage} %Centro

\renewcommand{\sectionmark}[1]{\markright{\thesection.\ #1}}
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0.5pt}

\newpage
\section{Certificado de la Empresa}
\newpage
\section{Observaciones}
\newpage
% =============== INDICE ===============

\tableofcontents
\listoffigures

% =============== SECCION ===============
\newpage
\section{Resumen}

El trabajo se realizó entre Agosto y Octubre del 2015 en NIC Chile Research Labs, el laboratorio de investigación y desarrollo en protocolos de internet de la Facultad de Ciencias Físicas y Matemáticas de la Universidad de Chile. \@ Consistió en
\begin{enumerate}
    \item rediseñar e actualizar parte de la API del backend de BeCity, una aplicación Android desarrollada en el laboratorio, para que se adhiriera al modelo REST.
    \item diseñar e implementar un microservicio de manejo de imágenes para el proyecto SUR.
\end{enumerate}

BeCity es una aplicación móvil Android orientada a ciclistas, la cual pretende facilitar el tránsito del usuario por la ciudad. Cuenta con un servicio de búsqueda de rutas con ciclovías, y permite grabar los recorridos del usuario, guardando estadísticas de velocidad, distancia recorrida, calorías quemadas, etc. Funciona bajo el paradigna cliente-servidor: existe un servicio central (el backend) que almacena y maneja los datos, y la aplicación Android (el cliente) se comunica con este servicio para actualizar y obtener información. Esta comunicación se realiza mediante una API (Application Programming Interface) usando HTTP (HyperText Transfer Protocol), sobre la cual se realizó el trabajo previamente mencionado.\\

El rediseño de esta API tenía como fin su modernización y adaptación a estándares modernos, en específico el modelo REST (REpresentational State Transfer)\\

SUR (Southern URban observatory) es una plataforma que pretende centralizar todos los proyectos desarrollados en NICLabs. En este sentido, SUR se plantea como un backend unificado para los distintos servicios, ofreciendo funcionalidades comunes como autentificación de usuarios y manejo de recursos como imágenes, y generando una integración más estrecha entre los servicios.\\

El trabajo realizado en SUR consistió en el diseño y posterior implementación de un pequeño servidor de imágenes, capaz de administrar recursos gráficos de manera eficiente, escalable y simple. Dicho servicio se encuentra actualmente estable y funcionando en la plataforma SUR.
\newpage
\section{Introducción}
\subsection{Lugar de Trabajo}

NIC Chile Research Labs (en adelante, NICLabs)\cite{niclabs}, es el laboratorio de redes de la Facultad de Ciencias Físicas y Matemáticas de la Universidad de Chile. Fundado en 2007, sus principales áreas de investigación y desarrollo son protocolos de internet y seguridad informática.

El trabajo detallado en el presente informe se desarrolló entre octubre y diciembre del año 2015, de manera presencial en las instalaciones del laboratorio ubicadas en Av. Blanco Encalada 1975, Santiago, Chile.

\subsection{Equipo de Trabajo}

%Arreglar!%

NICLabs cuenta tanto con desarrolladores e investigadores de tiempo completo, así como con estudiantes de pre- y postgrado. En específico, el trabajo se desarrolló en una sala compartida con otras 6 personas de distintas especialidades (diseñadores, ingenieros y estudiantes de pregrado).

En cuanto a los proyectos descritos en el presente informe, ambos se desarrollaron bajo la dirección de Felipe Lalanne\cite{lalanne}, investigador y desarrollador experimentado del laboratorio. Cabe destacar que si bien existe un equipo de trabajo formalmente conformado para BeCity, éste sólo maneja y actualiza la versión actual del software, y por ende el practicante no se unió directamente a éste, ya que su trabajo consideraba el rediseño completo del backend.
Por otro lado, no existe grupo de trabajo para SUR, y el practicante trabajó directamente bajo la tutela del supervisor.
\newpage
\subsection{Software y Conceptos Importantes}
En términos generales, ambos proyectos se desarrollaron en el lenguaje de programación Python\cite{python}, utilizando además JetBrains Pycharm 5 Professional Edition\cite{pycharm} como IDE (\emph{Integrated Development Environment} - Entorno de Desarrollo Integrado) principal.

\subsubsection{REST}

El modelo REST (por sus siglas en inglés, ``Representational State Transfer'') es una serie de restricciones arquitecturales que, aplicadas a un servicio web, inducen una serie de propiedades deseables (e.g. escalabilidad, estabilidad, rendimiento, etc). Al estar relacionado sólamente con la estructura arquitectural del software, no especifica detalles de implementación, y es independiente del lenguage de programación escogido.\\

A continuación, se expondrán brevemente las restricciones impuestas por el modelo REST:
\begin{enumerate}
    \item \textbf{Modelo Cliente - Servidor} \@ Debe existir una clara separación de responsabilidades mediante una interfaz uniforme. Por ejemplo, el servidor debe encargarse del almacenamiento y procesamiento de los datos, pero no de la representación visual de éstos, y vice-versa en el caso del cliente.
    \item \textbf{\textit{Statelessness} - Ausencia de Estados} \@ El servidor no debe guardar información del estado del cliente entre solicitudes. El estado es almacenado por el cliente; cada solicitud debe ser independiente y contener toda la información necesaria para realizarse.
    \item \textbf{Caché} \@ El servidor debe poder guardar solicitudes en caché para poder responder futuras solicitudes de manera más expedita.
    \item \textbf{Transparencia de Capas} \@ El cliente no debe poder determinar si está conectado directamente al servidor o a un servicio intermedio (proxy, etc).
    \item \textbf{Uniformidad de la Interfaz} \@ A su vez puede separarse en:
    \begin{itemize}
        \item \emph{Separación de recursos y su representación} \@ La representación externa de los recursos (datos) debe ser independiente de como son almacenados por el servidor. A su vez, estas representaciones contienen toda la información necesaria para poder modificar el recurso original.
        \item \emph{Identificación Uniforme de Recursos} \@ Por ejemplo, mediante URI's\cite{uri}.
        \item \emph{Mensajes Autodescriptivos} \@ Cada mensaje incluye información de cómo procesarse.
    \end{itemize}
\end{enumerate}

\subsubsection{API}

Una API (Application Programming Interface), en el contexto de servicios web, es una interfaz de interacción entre los componentes de un modelo servidor-cliente. Específicamente en el caso de una API RESTful, consiste en un conjunto de puntos de enlace (o, cómo se les referirá en el presente informe, \emph{``vistas''}) públicos en el servidor, a través de los cuales un cliente puede comunicarse e interactuar con el servicio central, utilizando verbos estándar de HTTP (\texttt{GET}, \texttt{PUT}, \texttt{POST} y \texttt{DELETE}).

% explicar rest + http + api?

\subsubsection{PostgreSQL}

PostgreSQL\cite{postgres} es una de las principales implementaciones modernas del lenguaje SQL (Structured Query Language - Lenguaje Estructurado de Consultas) para bases de datos. Es un sistema de base de datos relacional ampliamente utilizado en la industria, y en específico, en BeCity se ocupa para el almacenamiento y consulta de los datos proporcionados por los usuarios.

\subsubsection{Python}

Python es un lenguaje de programación interpretado, dinámico y de alto nivel, con énfasis en la fácil lectura de su código y su brevedad sintáctica. Es un lenguaje multipropósito, apto para programas de pequeña y gran escala, y con soporte para múltiples paradigmas de programación (orientado a objetos, funcional, imperativo, etc).

En el contexto del trabajo realizado, Python, principalmente en su versión 2.7 (aunque en algunas instancias se ocupó también la versión más nueva del lenguaje, 3.5), fue el lenguaje escogido para el desarrollo de los servicios. Esto, ya que debido a su popularidad, cuenta con una gran cantidad de librerías bien documentadas y mantenidas que facilitaron el desarrollo.

\subsubsection{JSON}

JSON (JavaScript Object Notation), es un estándar abierto de codificación de datos para la comunicación entre servidor y cliente, en la cual los datos se codifican en pares atributo-valor en ``cleartext'' (es decir, texto legible por humanos).
Por ejemplo, el siguiente extracto ilustra una posible codificación de la FCFM en JSON:
\begin{lstlisting}[language=JSON]
{
    "Nombre": "Facultad de Ciencias Fisicas y Matematicas",
    "Universidad": "Universidad de Chile",
    "Direccion": {
        "Calle": "Beauchef",
        "Numero": 850,
        "Comuna": "Santiago",
        "Region": "Metropolitana",
        "Pais": "CHILE"
    }
}
\end{lstlisting}

\subsubsection{Redis}

Redis puede describirse como un ``almacén de estructuras de datos en disco'', y se utiliza comúnmente como base de datos y transmisor de mensajes; además, en conjunto con la librería \emph{RQWorker}[cite here] de Python, se puede utilizar como una cola de ejecución de tareas. Éste fue el uso que se le dió en el servidor de imágenes, para ejecutar ciertas tareas de tiempo de ejecución más largo de manera diferida.

%\subsubsection{Docker}
\subsubsection{BeCity}

BeCity es una aplicación para smartphones con el sistema operativo Android, la cual tiene como fin la recolección de datos de ciclistas (por ejemplo, recorridos populares en una ciudad o comuna). Además, ayuda a los usuarios a transitar de manera segura por la ciudad, ofreciendo rutas con ciclovías e información atingente.

\subsubsection{SUR - Southern Urban Observatory}

SUR es pretende ser un servicio de uso interno de INRIA Chile y NICLabs; una plataforma centralizada para todos los proyectos de ambos laboratorios. Pretende unificar de ésta manera muchos servicios que se encuentran replicados en los distintos proyectos (por ejemplo, manejo de usuarios) bajo una misma platforma, intengrando así de manera mucho más eficiente distintos proyectos y servicios otorgados por los laboratorios.

\subsection{Situación Previa}
\subsubsection{BeCity}

En agosto del 2015, BeCity como aplicación ya se encontraba en funcionamiento, siendo distribuída a través de la tienda de aplicaciones de Google, la ``Play Store'', y con su backend montado en el servidor de NICLabs. Sin embargo, si bien contaba con una API completa para la comunicación entre clientes y backend, ésta no seguía el estándar REST para servicios web, principalmente en lo que se refiere a la uniformidad de la interfaz y la transparencia de capas, además de no seguir el estándar HTTP (e.g. todas las solicitudes ocupaban el verbo GET independiente de si solicitaban o no un recurso del servidor). Dado estas condiciones, se había decidido reconstruirla desde cero siguiendo rigurosamente el modelo REST, para asegurar su futura escalabilidad y estabilidad.

\subsubsection{SUR}

Cuando el practicamente comenzó su trabajo en NICLabs, SUR como proyecto todavía no existía, por lo que todo el trabajo se desarrolló desde cero.
\pagebreak
\subsection{Descripción General del Trabajo}

\subsubsection{BeCity}

El practicante diseñó e implementó parte de la nueva API, en específico el módulo de manejo de usuarios, siguiendo las restricciones del modelo REST para servicios web. El trabajo realizado se puede dividir en dos etapas:
\begin{enumerate}
    \item \emph{Diseño y Documentación} \\ En esta etapa, el practicante estudió la API existente del módulo escogido para entender el funcionamiento interno de éste, y los métodos que presentaba su interfaz. Luego, se diseñó y documentó la nueva versión del módulo, con especial énfasis en la nueva interfaz.
    \item \emph{Implementación y Testeo} \\ Luego de diseñado y documentado el módulo, se procedió a la implementación de las funcionalidades en código. Se utilizó el proceso de desarrollo ``Test Driven Development'', es decir, primero se escribían tests para funcionalidades deseadas, y luego se implementaban.
\end{enumerate}

\subsubsection{SUR}

El trabajo realizado en SUR consistió en el desarrollo de un servicio de manejo de imágenes centralizado para todos los proyectos de la plataforma. El servicio debía básicamente almacenar y servir imágenes proporcionadas por los proyectos, por ejemplo para avatares de usuario. Se requería especial énfasis en la modularidad del servicio, de tal manera de que pudiese interactuar con cualquier otro proyecto que se adhiriera a la plataforma SUR en el futuro.

El trabajo consistió de dos etapas:
\begin{enumerate}
    \item \emph{Diseño del Servicio}\\ Para comenzar, se determinaron los requerimientos del servicio; las funcionalidades deseadas y la manera de interactuar con éste.
    \item \emph{Implementación}\\ Ya establecidos los requerimientos, se implementó el sistema deseado.
\end{enumerate}

\newpage
\section{Trabajo Realizado}

\subsection{BeCity}

BeCity tiene como facilitar el tránsito del ciclista por la ciudad, a la vez que recopila información y estadísticas útiles proporcionadas por los mismos usuarios. Por lo tanto, el manejo de usuarios de una manera eficiente es fundamental para el funcionamiento del servicio, y por ende éste fue el primer módulo de funcionalidad en ser rediseñado para la nueva versión del backend.

\subsubsection{Análisis de implementación existente}

El primer paso en el rediseño del módulo de usuarios del backend de BeCity, fue el estudio y análisis de la implementación anterior. Esto con el fin de identificar funcionalidades claves que debían mantenerse o mejorarse en la nueva iteración del sistema.\\
Esta etapa se desarrolló al mismo tiempo que el practicante investigó de manera más profunda sobre el modelo REST y aprendió sobre el uso de las herramientas disponibles en Python para el desarrollo de sistemas de ésta índole.

\paragraph{Almacenamiento de la información de los usuarios}

\subsubsection{Diseño de nueva implementación}

A partir de análisis anterior, el practicante pudo elaborar un nuevo diseño para el backend, completamente en línea con los requerimientos del modelo REST. Este diseño se detalla a continuación, junto con justificaciones de las deciciones tomadas.

\paragraph{Almacenamiento de la información de los usuarios}

Se decidió continuar utilizando PostgreSQL para el almacenamiento de datos, por las ventajas que presenta para el almacenamiento de la información que maneja BeCity. La información manejada por el sistema es inherentemente relacional, puesto que se trata de datos de usuarios y estadísticas que se relacionan mutuamente.\\

En términos del modelo de la base de datos, la información de los usuarios se subdividió en tres tablas:
\begin{enumerate}
    \item Tabla User: Esta tabla almacena los datos fundamentales para la autentificación del usuario: su email, nombre de usuario y contraseña, esta última almacenada como un hash SHA256. Además, contiene relaciones con las dos otras tablas.
    \item Tabla UserDetails: Contiene los detalles no escenciales (desde el punto de vista de la autenficación) del usuario, como por ejemplo su nombre real y fecha de nacimiento.
    \item Tabla UserStats: Esta es una tabla especial que agrupa llaves foráneas a otra tabla, Sample. Cada entrada en esta última corresponde a una estadística almacenada (Sample por ejemplo almacena el último valor agregado, el máximo, el promedio, etc), por lo que cada llave foránea almacenada en UserStats corresponde a una estadística en Sample.
\end{enumerate}

Se determinó ésta subdivisión de la información con el fin de modularizar elementos puntuales - de ésta manera, por ejemplo, es posible modificar cómo se almacenan las estadísticas de cada usuario sin afectar su información de inicio de sesión.

\subsection{SUR}

Como se ha mencionado anteriormente, el proyecto SUR pretende ser una plataforma central para todos los proyectos de INRIA Chile y NICLabs - esto con el fin de centralizar varios servicios que actualmente se encuentran ``duplicados'' en todos los proyectos (por ejemplo, manejo de usuarios y de imágenes). Un servicio central como SUR permitiría que cierta información se pudiese compartir de manera transparente entre los proyectos y servicios, permitiedo por ejemplo que usuarios usen sus mismas credenciales de inicio de sesión, evitando la redundancia de tener que crear cuentas en cada uno de los servicios.
\\
Bajo esta lógica fue que al practicante se le solicitó la implementación del servicio central de imágenes, el cual permitiese compartir de manera transparente y eficiente recursos de imágenes (por ejemplo, avatares de usuario) entre los proyectos.

\subsubsection{Especificaciones}

El servicio en cuestión debía seguir una serie de especificaciones generales que aseguraban su eficiencia, escalabilidad y su compatibilidad con los demás servicios de la plataforma.

\begin{enumerate}
    \item \emph{Independencia:} \@ La implementación del servicio de imágenes debía ser independiente y agnóstica de la implementación del resto de los servicios. Es decir, si bien podía exister interdependencia entre el servicio de imágenes, y (por ejemplo) el servicio de autentificación, ésta no podía depender de la implementación de cada uno. Esto para asegurar que en el futuro, los servicios pudiesen actualizarse o cambiarse completamente sin perturbar el resto de los servicios en la plataforma.
    \item \emph{Adherencia al modelo REST} \@ El servicio debía basarse en el paradigma cliente-servidor, y seguir las especificaciones del modelo REST; comunicación mediante verbos HTTP, no almacenar estados, etc.
    \item \emph{Simplicidad} \@ El código debía ser simple y conciso, y no agregar demasiada complejidad al sistema.
    \item \emph{Instántaniedad} \@ Finalmente, la respuesta del servicio a solicitudes por parte de clientes debiese ser expedita, y no causar esperas prolongadas.
\end{enumerate}

Además, se establecieron una serie de requerimientos funcionales de los servicios que debía proveer el sistema:
\begin{enumerate}
    \item Almacenamiento de imágenes. Por simplicidad, sólo se debía aceptar imágenes en el formato \emph{Portable Network Graphics}, \textbf{.png}.
    \item Descarga de imágenes del servidor, en tamaños y resoluciones no necesariamente iguales a las originales.
    \item Eliminacion de imágenes almacenadas.
\end{enumerate}
\newpage
\subsubsection{Diseño Arquitectural}

En concordancia con las especificaciones y requerimientos anteriores, se llegó al diseño arquitectural detallado en esta sección.

El lenguaje escogido para la implementación fue nuevamente Python 2.7, principalmente por su amplio repertorio de librerías para desarrollo web, además de su simplicidad y elegancia sintáctica. Adicionalmente, es el lenguaje en el que están escritos todos los demás servicios de SUR, asegurando así una coherencia arquitectural interna de la plataforma.

Entre las librerías del lenguaje que fueron utilizadas, podemos destacar:
\begin{itemize}
    \item Flask\cite{flask}, la cual proporciona un framework básico para el desarrollo de aplicaciones web en Python. Por ejemplo, simplifica la ejecución de una aplicación Python como un servicio web asíncrono, y provee abstracciones para la implementación de endpoints (URL's) para interactuar con la aplicación.
    \item Pillow\cite{pillow}, librería de manejo de imágenes. Provee métodos de alteración de imágenes (transformaciones de tamaño, formato, etc).
\end{itemize}

Por otro lado, se descartó utilizar una base de datos para el servicio, ya que toda la información de las imágenes se puede manejar a través de \emph{metadatos} y almacenarse en el sistema de archivos. Agregar un sistema de bases de datos aumentaría la complejidad del sistema de manera innecesaria.\\

Finalmente, para poder asegurar la rapidez del servicio, se decidió realizar ciertas solicitudes de manera diferida -- esto es, no se ejecutan inmediatamente, sino que quedan en una cola de solicitudes y eventualmente se resuelven. Esto se implementó para solicitudes por parte de clientes que no requieren una respuesta inmediata del servidor y que además son intensas en términos de tiempo de ejecución (por ejemplo, la carga de una nueva imagen al servicio, ya que ésta operación requiere además un procesamiento posterior). Se efectuó mediante el uso de un servidor Redis en conjunto con el servicio de imágenes, el cual almacena y ejecuta las operaciones en la cola.
\newpage
\subsubsection{Implementación}

La implementación del código se llevó a cabo siguiendo una estrategia iterativa basada en tests, implementando funcionalidades básicas y asegurándose de su correcto funcionamiento mediante tests antes de pasar a funcionalidades más complejas.

\paragraph{1. Carga de imágenes al servidor}

Ésta fue la primera funcionalidad en implementarse en el servidor, dada que puede considerarse una de las dos funcionalidades fundamentales del servicio (la otra sería la descarga de imágenes).\\

Funciona de la siguiente manera: el servidor expone públicamente una vista (en este caso, ``/v1/images'') que acepta solicitudes HTTP con el verbo POST. Esta solicitud debe incluir los siguientes HEADERS:
\begin{verbatim}
    Content-Type: multipart/form-data
    Content-MD5: <checksum MD5 del archivo>
\end{verbatim}
Además, debe incluir el archivo a subir en formato binario en el cuerpo de la solicitud. \\

Al recibir la solicitud, el servidor primero ejecuta pruebas para verificar la existencia y validez de los datos proporcionados. En esta etapa el proceso puede arrojar tres variantes del mismo error HTTP ``400 Bad Request'', el cual se utiliza para notificar al cliente de que su solicitud no cumple con el formato requerido. En este caso, se lanza el error en caso de ausencia del archivo a cargar, o en caso de que la solicitud no incluya un HEADER con el hash MD5 de la imagen o que éste esté incorrecto.\\
Verificada la validez de la solicitud, el servidor pasa a almacenar y procesar la imagen (si la imagen ya existe en el sistema de archivos, el servidor simplemente retorna un mensaje HTTP ``201 Created''). En esta etapa también se verifica que el archivo cargado sea efectivamente una imagen, y el servidor retorna nuevamente un ``400 Bad Request'' de no ser así.\\

El procesamiento de las imágenes se hace de manera diferida - al terminar las verificaciones mencionadas previamente, el servidor guarda la imagen en disco y agrega un procedimiento a la cola de procesamiento del servidor Redis (además de retornar ``201 Created'' junto con el hash de la imagen al cliente). La rutina diferida de procesamiento ejecutada por el servidor Redis es la siguiente:

\begin{lstlisting}
def process_image(filename):
    """
    Deferred image handling routine.
    Generates a set of images of various resolutions from an original image.
    :param filename: ID of the original image.
    :rtype: None
    """
    try:
        o_img = Image.open(UPLOAD_FOLDER + filename + '/original.png', 'r')
        o_img.save(UPLOAD_FOLDER + filename + '/original.png', format='png')
        resolutions = app.config['STD_RESOLUTIONS']

        for resolution in resolutions:
            n_img = o_img.copy()
            n_img.thumbnail(resolution, Image.ANTIALIAS)
            n_img.save('{0}{1}/{2}.png'.format(UPLOAD_FOLDER, filename, resolution[0], resolution[1]), format='png')
            n_img.close()

        o_img.close()
    except IOError:
        shutil.rmtree(UPLOAD_FOLDER + filename)
\end{lstlisting}

Para evitar manejar los nombres de las imágenes (por ejemplo, por consideraciones de seguridad), éstas se identifican mediante su hash MD5: al recibir una imagen nueva, el servidor crea un directorio en la carpeta de imágenes cuyo nombre es el hash de la imagen, y luego almacena la imagen recibida bajo el nombre ``original.png'' dentro de dicho directorio. Luego, la rutina diferida ``process\_image()'' se encarga de crear múltiples resoluciones de la misma imagen para su rápido acceso en el futuro, las cuales se almacenan bajo el mismo directorio mencionado anteriormente.\\

Finalmente, una imagen con hash MD5 \texttt{CB5DED429F491D8337FC58006468CF35} cargada correctamente al servidor quedaría almacenada de la siguiente manera:
\begin{verbatim}
UPLOAD_FOLDER/
    CB5DED429F491D8337FC58006468CF35/
        original.png
        48.png
        128.png
        256.png
        ...
\end{verbatim}

Donde los archivos \texttt{48.png}, \texttt{128.png}, etc., corresponden a resoluciones específicas precalculadas para su rápido acceso en el futuro.

\paragraph{2. Descarga de imágenes}

La descarga de imágenes fue la segunda funcionalidad en implementarse, y funciona como se detalla a continuación.

Para descargar una imagen, el cliente debe conocer su ID (la cual corresponde al hash MD5 de la imagen). El servidor a su vez cuenta con una vista ``/v1/images/\textless image\_id\textgreater''; la notación \emph{\textless image\_id\textgreater} denota que esta parte del URL es variable - en específico, el cliente debe reemplazar \emph{\textless image\_id\textgreater} por la ID de la imagen que se solicita. Esta vista acepta los métodos GET y DELETE de HTTP (el verbo correspondiente a la solicitud de descarga es, evidentemente, el verbo GET), además de una serie de parámetros HTTP en el URL:
\begin{enumerate}
    \item tamaño precalculado: El cliente puede solicitar un tamaño precalculado de la imagen usando el parámetro \emph{``thumbnail=\textless thumb\_size\textgreater''} (de no existir, se creará).
    \item a escala: Utilizando el parámetro \emph{``scale=\textless scale\textgreater''}, se puede solicitar la imagen a cierta escala respecto al original.
    \item transformada: Finalmente, el cliente puede solicitar la transformación de la imagen mediante el uso de los parámetros \emph{``width=\textless w\textgreater''} y \emph{``height=\textless h\textgreater''} para especificar directamente el ancho y la altura de la imagen deseados, respectivamente.
\end{enumerate}

Por ejemplo, un cliente que desee obtener la imagen \texttt{CB5DED429F491D8337FC58006468CF35} transformada a \texttt{1280x720} (sin mantener la relación de aspecto), debería efectuar la siguiente solicitud:
\begin{verbatim}
GET /v1/images/CB5DED429F491D8337FC58006468CF35?width=1280&height=720
\end{verbatim}

Internamente, las solicitudes son manejadas por el servidor de la siguiente manera:
Primero, se verifica la existencia de la imagen, y de no existir se retorna un código de error ``404 Not Found'' al cliente.
Verificada ya la existencia de la imagen solicitada, se procede a servir la imagen de acuerdo a los parámetros solicitados por el cliente (si la solicitud no incluye parámetros, se retorna directamente la imagen original). De especial interés son aquellas solicitudes con el parámetro ``thumbnail'', ya que éstas son solicitudes para resoluciones populares y estándar de la imagen. Tienen el efecto de que, de no existir el tamaño solicitado, este es creado y almacenado por el servidor, de tal manera que futuras solicitudes para dicho tamaño sean más expeditas.\\

\begin{lstlisting}[title=Extracto de código encargado de manejar solicitudes de tamaños precalculados.]
# Thumbnail requests are done first, because they are faster
# System now checks if there is a precomputed size stored and sends that instead.
try:
    thumb = int(request.args.get('thumbnail', 0))
except ValueError:
    raise BadRequest400(error="Width, Height and Thumbnail must be Integers, Scale must be Float")
except TypeError:
    raise BadRequest400(error="Width, Height and Thumbnail must be Integers, Scale must be Float")

filename = UPLOAD_FOLDER + image_id + '/' + str(thumb) + '.png'

if thumb != 0 and os.path.exists(filename):  # if it exists, send it
    img = Image.open(filename)
    try:
        return send_image(img)
    except IOError:
        app.logger.error('Error when trying to send image ' + image_id)
        raise IOError

elif thumb != 0:  # if it doesn't, create and then send it
    img = img.copy()
    img.thumbnail((thumb, thumb), Image.ANTIALIAS)
    img.save(filename)

    try:
        return send_image(img)
    except IOError:
        app.logger.error('Error when trying to send image ' + image_id)
        raise IOError
\end{lstlisting}

Finalmente, se procesan las solicitudes con los parámetros de escala, ancho y alto, ya que estos requieren procesamiento en el lugar de la imagen, y demoran más.

\newpage
\section{Conclusiones}
\newpage
\begin{thebibliography}{5}
    \bibitem{niclabs} \emph{NIC Chile Research Labs} - \url{http://niclabs.cl}

    \bibitem{lalanne} \emph{Felipe Lalanne} - \url{https://github.com/pipex}

    \bibitem{postgres} \emph{PostgreSQL - ``The world's most advanced open source database.''}\\ \url{http://www.postgresql.org/}

    \bibitem{python} \emph{The Python Programming Language} - \url{https://www.python.org/}

    \bibitem{pycharm} \emph{JetBrains Pycharm} - \url{https://www.jetbrains.com/pycharm/}

    \bibitem{uri} \emph{URI - Uniform Resource Identifier}: cadena de caracteres utilizada para identificar recursos específicos, siguiendo un esquema definido.\\ \url{https://en.wikipedia.org/wiki/Uniform_Resource_Identifier}

	\bibitem{flask} \emph{Flask is a microframework for Python based on Werkzeug, Jinja 2 and good intentions.}\\ \url{http://flask.pocoo.org/}

    \bibitem{restless} \emph{Restless - A lightweight REST miniframework for Python.}\\ \url{https://restless.readthedocs.org/en/latest/}

    \bibitem{sqlalchemy}\emph{SQLAlchemy - The Python SQL Toolkit and Object Relational Mapper}\\ \url{http://www.sqlalchemy.org/}

    \bibitem{pillow}\emph{PILLOW - Python Imaging Library fork}\\ \url{https://pillow.readthedocs.org/en/3.1.x/}
\end{thebibliography}

% ============= FIN DE DOCUMENTO ==============
\end{document}

% % ················ IMAGEN ·················
% \begin{figure}[ht!]
% \centering
% \fbox{\includegraphics[scale=0.6]{img/flujo.png}}
% \caption{Flujo de caja anual}\label{flujo}
% \end{figure}\\begin{enumerate}
    \item a
\end{enumerate}
% %··········································

% % ················ IMAGEN DOBLE ·················
% \begin{figure}[ht!] \centering
% \subfloat[Esquemático]{\includegraphics[scale=0.44]{img/seguidor.png}}
% \subfloat[Simulación]{\includegraphics[scale=0.45]{img/seguidor1.png}}
% \caption{Simulación como seguidor de voltaje}\label{seguidor}
% \end{figure}
% %··········································
